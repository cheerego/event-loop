##  什么是事件循环

>The event loop is what allows Node.js to perform non-blocking I/O operations — despite the fact that JavaScript is single-threaded — by offloading operations to the system kernel whenever possible.

事件循环允许 Node.js 执行非阻塞 I/O 操作 - 尽管JavaScript是单线程的 - 通过尽可能将操作让系统内核执行。

由于大多数现代内核都是多线程的，因此它们可以处理在后台执行的多个操作。当其中一个操作完成时，内核会告诉Node.js，以便可以将相应的回调添加到轮询队列中以最终执行。我们将在本主题后面进一步详细解释。



#### Event Loop 概述

当Node.js启动时，它初始化事件循环，处理提供的输入脚本（或放入REPL，本文档中未涉及），这可能会进行异步API调用，调度计时器或调用 process.nextTick()，然后开始处理事件环。

每个阶段都有一个要执行的回调FIFO队列。虽然每个阶段都以其自己的方式特殊，但通常情况下，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后在该阶段的队列中执行回调，直到队列耗尽或最大回调数量为止已执行。当队列耗尽或达到回调限制时，事件循环将移至下一阶段，依此类推。

下图显示了事件循环操作顺序的简要概述。
```
   ┌───────────────────────┐
┌─>│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     pending callbacks │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   incoming:   │
│  │         poll          │<─────┤  connections, │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘

```
* **timers**:此阶段执行由setTimeout() 和调度的回调setInterval()    
* **pending callbacks**:执行除了 close事件的callbacks、被timers(定时器，setTimeout、setInterval等)设定的callbacks、setImmediate()设定的callbacks之外的callbacks
* **idle, prepare**:仅在内部使用
* **poll**:获取新的I/O事件, 适当的条件下node将阻塞在这里
* **check**:setImmediate()在这里调用回调 
* **close callbacks**:一些关闭回调，例如socket.on('close', ...)



> https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

>https://segmentfault.com/a/1190000012258592

Node Event loop为什么要分成六个阶段，这样做和浏览器的实现原

https://www.jianshu.com/p/b221e6e36dcb
